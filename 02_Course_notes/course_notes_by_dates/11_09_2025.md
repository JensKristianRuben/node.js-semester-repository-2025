# Loop methods

## Nodemon Basics and Limitations

- Nodemon is a development tool that is extremely smart and time-saving, because we don’t have to restart our server every time we make a small change. This means we don’t have to manually type `node app.js` each time we want to test server changes — Nodemon automatically refreshes when it detects a change. It’s important to remember that Nodemon is only for development and should **not** be used in production environments.

You can install Nodemon globally like this — it’s useful if, like me, you have many small Node.js projects and make minor changes in different places. It allows you to run Nodemon directly from the terminal:

```bash
npm install -g nodemon
```

Once Nodemon is installed, you can start your app by running:

```bash
nodemon app.js
```

Now, whenever changes are made, you’ll see in the terminal that the application restarts automatically. Happy coding!

## JavaScript Loops and Loop Methods

- JavaScript offers different ways to iterate through data structures. As we know, you can use traditional `for` loops where you define a variable, set a loop condition, and specify how much the variable should increment each iteration. Generally, we want to avoid using this type of loop to iterate over data structures — primarily only if you are “counting with your fingers.” Otherwise, we use loop methods. Examples include:

- `.forEach()`, `.find()`, `.filter()`, `.map()`, `.reduce()`, `.indexOf()` — methods that use loop logic.

For example, you can use `.forEach()` if you don’t care about the original values and just want to traverse a list. It is a void method, so it does not return a new array. For example:

```js
const numbers = [1, 2, 3, 4, 5];

numbers.forEach((element) => console.log(element * 2));
```

You can also use `.map()`, which returns a new array with each element transformed according to your logic. For example, if you want to multiply each element by 2:

```js
const numbers = [1, 2, 3, 4, 5];

const newNumbers = numbers.map((element) => element * 2);
```

- You can also use `.find()`, which returns the **first value** in an array that matches a condition. If no matching element is found, it returns `undefined`. For example:

```js
const numbers = [1, 2, 3, 4, 5];

const numberFour = numbers.find((number) => number === 4);
console.log("number is:", numberFour);
```

- You can also use `.filter()`, which returns a **new array** containing only the values that match a specific condition. It's a bit like a sieve that filters things out. For example:

```js
const numbers = [1, 2, 3, 4, 5];

const evenNumbers = numbers.filter((number) => number % 2 === 0);
console.log("even numbers: ", evenNumbers);
```

`.reduce()` reduces an array to a single value by applying a function to accumulate results.

Example: Sum of all numbers in an array:

```js
const numbers = [1, 2, 3, 4, 5];


// jeg fatter ikke reduce
const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum);
```

`.indexof()` gives us the index of the value we are looking for. return either the index or -1 if no value matches the one we want. could look like this:

```js
const fruits = ["Thanos", "Loki", "Doctor Doom", "Magneto"];

const index = fruits.indexOf("Thanos");
console.log(index); // 1

const notFound = fruits.indexOf("Thor");
console.log(notFound); // -1
```

## Functional Programming with Loop Methods

## CRUDable REST API – Part I

## URL Anatomy and Terminology

## Client-to-Server Data Transfer Methods

## Serving HTML with Express

## Handling POST Requests and Parsing Bodies in Express
