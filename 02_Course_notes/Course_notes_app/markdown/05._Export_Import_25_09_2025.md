 # EXPORT / IMPORT
 
 ## STATIC FILES IN EXPRESS

What are static files? They are the files that donâ€™t change on the server but simply need to be sent to the client. These could be images (png/jpg), HTML files, CSS files, and JS files. Our Express server doesnâ€™t automatically make all files available to the client â€” quite the opposite. This is actually a good thing, because it means that sensitive files arenâ€™t just freely accessible when someone interacts with our website. However, it also means that we need to explicitly specify which files the client is allowed to access. 

One thing we could do is send all the static files one by one, so they can be used across the client. For example, it could look like this:

```js
app.get("/Stylesheet", (req, res) => {
  const stylesheet = path.join(__dirname, "public", "styles.css")

  app.send(stylesheet)
});
```

You could do the same for all static files and access them in the client that way.

## IMPORTING FRONTEND

When working with HTML and adding JavaScript, there are different ways to reference the JavaScript code. For example, you can write the JavaScript directly inside the HTML file, within a `<script>` tag. However, in the long run and in larger projects, this approach is not ideal â€” it quickly becomes messy and difficult to maintain.

If we want to have a clearer structure for which scripts belong to what, we can place them in separate files. But even then, there are two different ways to reference the JavaScript.

The first and traditional way does not use the import/export syntax. Instead, you reference the specific file in the `<script>` tag like this:

```html
<script src="index.js"></script>

```

It means that everything in the script ends up in the global scope â€” at first, you might think, "Great, Iâ€™ll take that. I get everything and can use everything." But in the long run, it can cause problems because you lose track of what affects what â€” you might use some functionality somewhere that youâ€™ve forgotten about or didnâ€™t intend to use, simply because the functionality is global. It also means that name conflicts can arise, since the scripts are global, and if you use common, generic names in both files, as one often does, it can result in side effects that are difficult to debug.

It can also be difficult to modularize the code and reuse it elsewhere because the entire code is accessible, which means the whole script will be loaded if you want to use a single function in another place.

So one solution to this is to use `type=module`, which is a more modern way to reference JavaScript. Here, you can use the import/export syntax. This means you can export functions or data from one file and access them in another â€” I will go into more detail on how later in a separate section. The HTML syntax itself looks as follows:

```html
<script type="module" src="index.js"></script>
```

Itâ€™s convenient because it also ensures that each module has its own scope and is not affected by global variables. Files are loaded asynchronously, which also optimizes page loading. Another advantage is that the browser handles dependencies automatically, so you donâ€™t have to worry about the order in the HTML.


## COMMONJS VS ES MODULES

CommonJS and ES modules are related to what we just discussed in the previous section. CommonJS is the module system developed alongside Node.js â€” it uses require() to import libraries and dependencies. It is easy to understand and use in smaller server-side projects. When you want to import something using CommonJS, it looks like this:

```js
const express = require("express");
```
ES modules are the modern module system in JavaScript â€” they were introduced with ECMAScript back in 2015 (ES6). They use the import/export syntax. In earlier sections, we discussed some of the advantages of ES modules and why we want to use them. To that, I can add that it obviously makes the most sense to use things that are also future-compatible. The syntax for using ES modules can look like this:

```js
export function hallo(name) {
  console.log("Hallo " + name);
} 
```


I have that in one file â€” letâ€™s call it file1.js. In the other file, file2.js, I can now import the method directly from file1.js using:

```js
import { hallo } from "./util/candyESModule.js";

hallo("Jens"); // Hallo Jens
```
You could say that in this way, you need to be quite conscious and explicit about which pieces of code you want to share with another file. It also means that you can easily encapsulate logic in a file â€” for example, a variable â€” and use it in a function that you export to another file. But you need to be very aware of what you are exporting and importing in your files.

You can also use the keyword `default`, which indicates that the exported element is the main element and can be used directly â€” it also means you donâ€™t need `{ }` around the name when importing it. It looks like this:

```js
import  hallo  from "./util/candyESModule.js";
```


## REDIRECTION

A redirect is when youâ€™re sent from one URL to another â€” it can easily happen within the same website â€” it just means the URL changes, and the content probably does too. Itâ€™s kind of weird to redirect from one URL to another with exactly the same content â€” hmm ðŸ¤”

You can redirect in different ways â€” Iâ€™ll go over two here: server-side redirecting and client-side redirecting.

**SERVER-SIDE**
When you create a redirect on the server, the server responds to the request with a status code 301, which means Moved Permanently, and a location â€” the path the new request should be sent to. This results in the client making a new request to the new path, the URL updates, and the new page is displayed if the request can be handled.

You use the res object with the redirect() method, which can take two parameters â€” the status code and the path the URL should be redirected to.

Itâ€™s smart to redirect on the server side because you can handle logic, such as saving data, before asking the client to make a new request. Itâ€™s also good for SEO, since search engines understand status codes and what they mean.

It also works well for security â€” for example, you can redirect users who arenâ€™t logged in. You could even argue that itâ€™s not dependent on JavaScript, and therefore works for all clients â€” kind of funny, since our backend is written in JavaScript :P

A redirect could look like this:

```js
app.get("/old-page", (req, res) => {
    // saving alot of important data right here or checking to see if the user is logged in
  res.redirect(301, "/new-page");
});
```

**CLEINT-SIDE**
Client-side redirect still works by sending a request to the server using the URL that has been changed, but itâ€™s the code running in the client that handles it.

This could, for example, be an a tag that uses the window object to change the URL via the elementâ€™s href attribute. That means the client now sends a new request to the server for the URL that the window object changed the URL to.

If itâ€™s a relative path, the same domain will be used; if itâ€™s an absolute path, a new request will be made to that URL. Finally, the browser clears the DOM and refreshes the page. The history will also be updated, so you can go back to the previous page.

It could look like this in the HTML:

```html
<a href="/markdown/05._Export_Import_25_09_2025" class="navigation-menu-item">Export / Import</a>

```