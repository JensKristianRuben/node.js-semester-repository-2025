# Statiske filer

- Man kan bruge `app.use(express.static("public"));` for at servere den statiske mappe til frontend.  

- Hvis vi gerne vil bruge et scripts logik i en HTML-fil, kan vi enten skrive det direkte i filen eller linke til filen.  

- Metoder hører til klasser, mens functions bare står alene.  

- Der er en ulempe ved at loade flere forskellige JavaScript-filer på én gang, da det kommer til at fylde i memory.  

- Der findes forskellige måder at importere scripts på – enten som vi kender det, hvor man sender hele scriptet i en fil, eller ved at bruge *default export* med `type="module"`.  

- Fremadrettet bruger vi altid `import` på modul-måden – vi bruger ikke `require` længere.  

- Vi kan ikke længere bruge `__dirname`; i stedet skal vi bruge `path`, f.eks. `path.resolve("path")`.  


## STATIC FILES IN EXPRESS

What are static files? They are the files that don’t change on the server but simply need to be sent to the client. These could be images (png/jpg), HTML files, CSS files, and JS files. Our Express server doesn’t automatically make all files available to the client — quite the opposite. This is actually a good thing, because it means that sensitive files aren’t just freely accessible when someone interacts with our website. However, it also means that we need to explicitly specify which files the client is allowed to access. 

One thing we could do is send all the static files one by one, so they can be used across the client. For example, it could look like this:

```js
app.get("/Stylesheet", (req, res) => {
  const stylesheet = path.join(__dirname, "public", "styles.css")

  app.send(stylesheet)
});
```

You could do the same for all static files and access them in the client that way.

## IMPORTING FRONTEND

When working with HTML and adding JavaScript, there are different ways to reference the JavaScript code. For example, you can write the JavaScript directly inside the HTML file, within a `<script>` tag. However, in the long run and in larger projects, this approach is not ideal — it quickly becomes messy and difficult to maintain.

If we want to have a clearer structure for which scripts belong to what, we can place them in separate files. But even then, there are two different ways to reference the JavaScript.

The first and traditional way does not use the import/export syntax. Instead, you reference the specific file in the `<script>` tag like this:

```html
<script src="index.js"></script>

```

It means that everything in the script ends up in the global scope — at first, you might think, "Great, I’ll take that. I get everything and can use everything." But in the long run, it can cause problems because you lose track of what affects what — you might use some functionality somewhere that you’ve forgotten about or didn’t intend to use, simply because the functionality is global. It also means that name conflicts can arise, since the scripts are global, and if you use common, generic names in both files, as one often does, it can result in side effects that are difficult to debug.

It can also be difficult to modularize the code and reuse it elsewhere because the entire code is accessible, which means the whole script will be loaded if you want to use a single function in another place.

So one solution to this is to use `type=module`, which is a more modern way to reference JavaScript. Here, you can use the import/export syntax. This means you can export functions or data from one file and access them in another — I will go into more detail on how later in a separate section. The HTML syntax itself looks as follows:

```html
<script type="module" src="index.js"></script>
```

It’s convenient because it also ensures that each module has its own scope and is not affected by global variables. Files are loaded asynchronously, which also optimizes page loading. Another advantage is that the browser handles dependencies automatically, so you don’t have to worry about the order in the HTML.


## COMMONJS VS ES MODULES


## Redirection


## NPM / PACKAGE.JSON

