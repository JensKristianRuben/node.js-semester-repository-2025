# Statiske filer

- Man kan bruge `app.use(express.static("public"));` for at servere den statiske mappe til frontend.  

- Hvis vi gerne vil bruge et scripts logik i en HTML-fil, kan vi enten skrive det direkte i filen eller linke til filen.  

- Metoder hører til klasser, mens functions bare står alene.  

- Der er en ulempe ved at loade flere forskellige JavaScript-filer på én gang, da det kommer til at fylde i memory.  

- Der findes forskellige måder at importere scripts på – enten som vi kender det, hvor man sender hele scriptet i en fil, eller ved at bruge *default export* med `type="module"`.  

- Fremadrettet bruger vi altid `import` på modul-måden – vi bruger ikke `require` længere.  

- Vi kan ikke længere bruge `__dirname`; i stedet skal vi bruge `path`, f.eks. `path.resolve("path")`.  


## STATIC FILES IN EXPRESS

What are static files? They are the files that don’t change on the server but simply need to be sent to the client. These could be images (png/jpg), HTML files, CSS files, and JS files. Our Express server doesn’t automatically make all files available to the client — quite the opposite. This is actually a good thing, because it means that sensitive files aren’t just freely accessible when someone interacts with our website. However, it also means that we need to explicitly specify which files the client is allowed to access. 

One thing we could do is send all the static files one by one, so they can be used across the client. For example, it could look like this:

```js
app.get("/Stylesheet", (req, res) => {
  const stylesheet = path.join(__dirname, "public", "styles.css")

  app.send(stylesheet)
});
```

You could do the same for all static files and access them in the client that way.

## IMPORTING FRONTEND

When working with HTML and adding JavaScript, there are different ways to reference the JavaScript code. For example, you can write the JavaScript directly inside the HTML file, within a `<script>` tag. However, in the long run and in larger projects, this approach is not ideal — it quickly becomes messy and difficult to maintain.

If we want to have a clearer structure for which scripts belong to what, we can place them in separate files. But even then, there are two different ways to reference the JavaScript.

The first and traditional way does not use the import/export syntax. Instead, you reference the specific file in the `<script>` tag like this:

```html
<script src="index.js"></script>

```

It means that everything in the script ends up in the global scope — at first, you might think, "Great, I’ll take that. I get everything and can use everything." But in the long run, it can cause problems because you lose track of what affects what — you might use some functionality somewhere that you’ve forgotten about or didn’t intend to use, simply because the functionality is global. It also means that name conflicts can arise, since the scripts are global, and if you use common, generic names in both files, as one often does, it can result in side effects that are difficult to debug.

It can also be difficult to modularize the code and reuse it elsewhere because the entire code is accessible, which means the whole script will be loaded if you want to use a single function in another place.

So one solution to this is to use `type=module`, which is a more modern way to reference JavaScript. Here, you can use the import/export syntax. This means you can export functions or data from one file and access them in another — I will go into more detail on how later in a separate section. The HTML syntax itself looks as follows:

```html
<script type="module" src="index.js"></script>
```

It’s convenient because it also ensures that each module has its own scope and is not affected by global variables. Files are loaded asynchronously, which also optimizes page loading. Another advantage is that the browser handles dependencies automatically, so you don’t have to worry about the order in the HTML.


## COMMONJS VS ES MODULES

CommonJS and ES modules are related to what we just discussed in the previous section. CommonJS is the module system developed alongside Node.js — it uses require() to import libraries and dependencies. It is easy to understand and use in smaller server-side projects. When you want to import something using CommonJS, it looks like this:

```js
const express = require("express");
```
ES modules are the modern module system in JavaScript — they were introduced with ECMAScript back in 2015 (ES6). They use the import/export syntax. In earlier sections, we discussed some of the advantages of ES modules and why we want to use them. To that, I can add that it obviously makes the most sense to use things that are also future-compatible. The syntax for using ES modules can look like this:

```js
export function hallo(name) {
  console.log("Hallo " + name);
} 
```
I have that in one file — let’s call it file1.js. In the other file, file2.js, I can now import the method directly from file1.js using:

```js
import { hallo } from "./util/candyESModule.js";

hallo("Jens"); // Hallo Jens
```
You could say that in this way, you need to be quite conscious and explicit about which pieces of code you want to share with another file. It also means that you can easily encapsulate logic in a file — for example, a variable — and use it in a function that you export to another file. But you need to be very aware of what you are exporting and importing in your files.

You can also use the keyword `default`, which indicates that the exported element is the main element and can be used directly — it also means you don’t need `{ }` around the name when importing it. It looks like this:

```js
import  hallo  from "./util/candyESModule.js";
```


## Redirection



## NPM / PACKAGE.JSON

