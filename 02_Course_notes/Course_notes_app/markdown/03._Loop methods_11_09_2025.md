# Loop methods

## Nodemon Basics and Limitations

- Nodemon is a development tool that is extremely smart and time-saving, because we don’t have to restart our server every time we make a small change. This means we don’t have to manually type `node app.js` each time we want to test server changes — Nodemon automatically refreshes when it detects a change. It’s important to remember that Nodemon is only for development and should **not** be used in production environments.

You can install Nodemon globally like this — it’s useful if, like me, you have many small Node.js projects and make minor changes in different places. It allows you to run Nodemon directly from the terminal:

```bash
npm install -g nodemon
```

Once Nodemon is installed, you can start your app by running:

```bash
nodemon app.js
```

Now, whenever changes are made, you’ll see in the terminal that the application restarts automatically. Happy coding!

## JavaScript Loops and Loop Methods

- JavaScript offers different ways to iterate through data structures. As we know, you can use traditional `for` loops where you define a variable, set a loop condition, and specify how much the variable should increment each iteration. Generally, we want to avoid using this type of loop to iterate over data structures — primarily only if you are “counting with your fingers.” Otherwise, we use loop methods. Examples include:

- `.forEach()`, `.find()`, `.filter()`, `.map()`, `.reduce()`, `.indexOf()` — methods that use loop logic.

For example, you can use `.forEach()` if you don’t care about the original values and just want to traverse a list. It is a void method, so it does not return a new array. For example:

```js
const numbers = [1, 2, 3, 4, 5];

numbers.forEach((element) => console.log(element * 2));
```

You can also use `.map()`, which returns a new array with each element transformed according to your logic. For example, if you want to multiply each element by 2:

```js
const numbers = [1, 2, 3, 4, 5];

const newNumbers = numbers.map((element) => element * 2);
```

- You can also use `.find()`, which returns the **first value** in an array that matches a condition. If no matching element is found, it returns `undefined`. For example:

```js
const numbers = [1, 2, 3, 4, 5];

const numberFour = numbers.find((number) => number === 4);
console.log("number is:", numberFour);
```

- You can also use `.filter()`, which returns a **new array** containing only the values that match a specific condition. It's a bit like a sieve that filters things out. For example:

```js
const numbers = [1, 2, 3, 4, 5];

const evenNumbers = numbers.filter((number) => number % 2 === 0);
console.log("even numbers: ", evenNumbers);
```

`.reduce()` reduces an array to a single value by applying a function to accumulate results.

Example: Sum of all numbers in an array:

```js
const numbers = [1, 2, 3, 4, 5];

// jeg fatter ikke reduce
const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum);
```

`.indexof()` gives us the index of the value we are looking for. return either the index or -1 if no value matches the one we want. could look like this:

```js
const fruits = ["Thanos", "Loki", "Doctor Doom", "Magneto"];

const index = fruits.indexOf("Thanos");
console.log(index); // 1

const notFound = fruits.indexOf("Thor");
console.log(notFound); // -1
```

- Alternative loops kunne være at bruge et while loop som, som kører indtil en condition er sand eller falsk, alt efter hvad man gør, feks:

```js
let numberOfIterations = 1;

while (numberOfIterations <= 5) {
  console.log("Iteration:", numberOfIterations);
  numberOfIterations++;
}
```

## Functional Programming with Loop Methods

- Functional programming is fundamentally about avoiding changes to existing data (no mutation).

I can show two different examples that achieve the same result, but one contains side effects while the other does not.

With side effects:

```js
const number = [1, 2, 3, 4];
let doubled = [];

number.forEach((number) => {
  doubled.push(number * 2);
});

console.log("Numbers doubled: ", doubled);
```

This is a side effect because the value exists outside the function but is modified inside it. The code can become harder to debug and maintain, as changes can happen “behind the scenes.”

The exact same operation can be written without side effects:

```js
const numbers = [1, 2, 3, 4];
const numbersWithoutSideEffect = numbers.map((number) => number * 2);
```

- JEG FATTER DET SKU IKKE HELT

## URL Anatomy and Terminology

- It is important to understand how a URL is designed and why it looks the way it does. Let's take a database containing Harry Potter characters as an example – it could look like this:

`https://hpapi.com/v1/characters`

- `https://` – the protocol, which specifies how the client communicates with the server.
- `hpapi.com` – the domain, i.e., the server's address. This is where all the characters “live.” You could call it Hogwarts.
- `.com` – called the top-level domain (TLD).
- `v1` – sometimes used to version the API. This is useful if a new version is released in the future.
- `characters` – specifies which resource we want to access.

One can imagine that an API could also allow query parameters, for example:

`https://hpapi.com/v1/characters/?house=gryffindor&sort=name`

- `?house=gryffindor&sort=name` are query parameters, a way to extend the request to Hogwarts. Here, we ask only for characters from Gryffindor, and we want them sorted by name.
- Not all APIs can handle such parameters, but many can.

## Client-to-Server Data Transfer Methods

- `Query Parameters`

- `Request Body`

- `Headers`

## Serving HTML with Express

- How can you send files from your server to the client? In a GET endpoint, you can serve the file to the view using the `sendFile()` method. It is important to make the file path generic so that it works on your local machine, someone else’s machine, or the server. You can use `__dirname` as the path to the project’s root folder. You can also use `path.resolve()`. It could look like this:

```js
app.get("/", (req, res) => {
  res.sendFile(path.resolve("public/frontend/index.html"));
});
```

## Handling POST Requests and Parsing Bodies in Express

- When you receive a request in Express, you initially get a long string that cannot yet be understood or used as JSON data. Therefore, you need to include the Express middleware that can parse JSON, especially if you want to use functionality like `req.body.name`.

If we want to work with JSON in our code, we can use this line:

`app.use(express.json());`

this is one reason why express is called Unopinionated.