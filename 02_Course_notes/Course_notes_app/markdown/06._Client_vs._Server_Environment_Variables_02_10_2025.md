# ENVIROMENT VARIABLES / NPM SCRIPTS

In Node, you can set environment variables in a few different ways. For example, you can choose to set them via a command when starting your server. This could be done with the following syntax:

```powershell
$env:PORT="8080"; nodemon app.js
```

Here, an environment variable is set in the terminal session, which can be accessed via PORT through the process object. This is PowerShell syntax, and it’s important to be aware that the syntax differs between Bash, CMD, and PowerShell in these situations.

If we want to use the environment variable in our code, it might look like this:

```js
const PORT = Number(process.env.PORT);
```

Man kan lave det her lille lækre trick med at caste det til Number for at den fremstår gul i konsollen - det er tjekket.

For some, it can take a long time if you have to type these commands every time you start your server — we can solve this by adding the scripts to our package.json file and giving them aliases that we can run instead. It could look something like this:

```json
 "scripts": {
    "dev": "cross-env PORT=8080 nodemon app.js",
    "startWinCMD": "set PORT=8080 && nodemon app.js",
  }
```

That means we can simply run:

```bash
  npm run dev
```

That starts our server with the environment variable and runs it using nodemon. However, it can be a problem that we have to use different commands depending on which operating system we’re running — cross-env can help us with that. It translates the command so it works on whichever operating system the computer is using.

We can also use the package.json scripts to run a development version and a production version of our server — for example, we don’t want to run nodemon on the production server.

# SAVE-DEV DEPENDENCIES

When you install a dependency with --save-dev (or -D) in npm, the package is added under devDependencies in package.json. This means the package is only needed during development and will not be installed in production when running npm install --production. Typical examples of devDependencies are tools like eslint, nodemon, or testing libraries, which don’t need to be included in the final application.

This will appear in package.json as:

```json
"devDependencies": {
    "cross-env": "^10.1.0"
  }
```

# FETCH BACKEND VS FRONTEND

We can fetch data both from other sources on the client side and on the server side. Here, I’ll try to separate the two methods and explain the difference. The method for fetching data on the server and on the client can be done in the same way, but there are some essential differences and possibilities between them.

If we want to fetch data on the frontend, we can do it using fetch with either await or .then syntax — it doesn’t matter. We’ve previously worked with the Books API and its design — the fetch could look like this:

```js
fetch("https://books.com/api/books")
  .then((response) => response.json())
  .then((result) => console.log(result));
```

When we work with fetch in the frontend, we are subject to the rules imposed by the browser—for example, CORS restrictions. One disadvantage of fetching on the frontend is that we might expose our API key. If we want to use an API key without others being able to see it, we can choose to fetch the data on the server—this could look like this:

```js
const response = await fetch("https://books.com/api/books");
const result = await response.json();
console.log(result);
```

The possibilities on the server are a bit different because we can store and use secrets, we don’t have CORS restrictions, and we can process and manipulate our data more complexly before sending it to the frontend. If we just want to display data immediately, we do it on the client; if we want to fetch data and model it in large processes, or need to keep API keys secure, we do it on the server and then send it to the frontend.

# SEMANTIC HTML

Semantic HTML is about being intentional with the HTML tags you use — so they are optimized for accessibility, SEO, and readability for search engines. Normally, you might just use `<div>` for everything because it’s easy to style and use — but that’s not very smart when it comes to HTML semantics.

What we definitely want to do is use `<nav>` for our navigation bar, `<main>` for our main content, and `<footer>` for our closing element that sits at the bottom of a webpage. You also need to be mindful of `<h1>`, `<h2>`, `<h3>` because search engines use them to determine the importance of information — whether it’s a heading or a subheading, etc. For example, it makes sense to have only one `<h1>` tag per page, while you can have multiple `<p>` tags or `<h2>`, `<h3>` tags.

# CLIENT FILES VS SERVER FILES

# HOW TO STYLE A FOOTER SO IT STAYS AT THE BOTTOM

Det er måske noget alle på et tidspunkts slås med? en løsning på det kunne være at bruge flexbox med min-height og flex: 1 i main tagget. Det ville sørge for at skubbe footer elementet ned i bunden lige meget hvor meget main elementet fyldte. Det ville være dynamisk all the way. Det kunne se ud på følgende måde:

```html
<body>
  <div class="page-wrapper">
    <header>Header</header>
    <main>Main content</main>
    <footer>Footer</footer>
  </div>
</body>
```

With the css:

# FRONTEND STRUCTURE

There isn’t a very strict convention for how to structure your frontend — in many server-side languages or frameworks, there are tighter structures for how to set up your project, but not here. That doesn’t mean we should turn a blind eye to it and not handle it. We want to create a structure that’s optimized and works to our advantage.

At its core, it’s about creating a structure that’s easy and quick to understand, so that as a project grows, it remains easy to maintain.

For a long time, I’ve worked with a structure divided into folders that contain the HTML, CSS, and JavaScript — each file is named the same, so it’s easy to see which files belong together based on their names. That structure makes sense to me mainly because it’s what I’ve worked with the most — I’ll admit that’s not the strongest argument.

I also think a good structure could be organizing by pages, where each page has its own folder containing the related scripts and styles. That makes it quick and easy to find the folder you want to look in.

# shortcircuit syntaks

- Det her eller det her. google hvad det betyder

# proxying

- man kan lave en proxy ved at at fetche en URL - f.eks. google - også kan man sende dataen tilbage til clienten:

```js
app.get("/proxy", (req, res) => {
  fetch("https://www.google.com/")
    .then((response) => response.text())
    .then((body) => {
      res.send(body);
    });
});
```
