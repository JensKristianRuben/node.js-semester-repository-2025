# ENVIROMENT VARIABLES / NPM SCRIPTS

In Node, you can set environment variables in a few different ways. For example, you can choose to set them via a command when starting your server. This could be done with the following syntax:

```powershell
$env:PORT="8080"; nodemon app.js
```

Here, an environment variable is set in the terminal session, which can be accessed via PORT through the process object. This is PowerShell syntax, and it’s important to be aware that the syntax differs between Bash, CMD, and PowerShell in these situations.

If we want to use the environment variable in our code, it might look like this:

```js
const PORT = Number(process.env.PORT);
```

Man kan lave det her lille lækre trick med at caste det til Number for at den fremstår gul i konsollen - det er tjekket.

For some, it can take a long time if you have to type these commands every time you start your server — we can solve this by adding the scripts to our package.json file and giving them aliases that we can run instead. It could look something like this:

```json
 "scripts": {
    "dev": "cross-env PORT=8080 nodemon app.js",
    "startWinCMD": "set PORT=8080 && nodemon app.js",
  }
```

That means we can simply run:

```bash
  npm run dev
```

That starts our server with the environment variable and runs it using nodemon. However, it can be a problem that we have to use different commands depending on which operating system we’re running — cross-env can help us with that. It translates the command so it works on whichever operating system the computer is using.

We can also use the package.json scripts to run a development version and a production version of our server — for example, we don’t want to run nodemon on the production server.

# SAVE-DEV DEPENDENCIES

When you install a dependency with --save-dev (or -D) in npm, the package is added under devDependencies in package.json. This means the package is only needed during development and will not be installed in production when running npm install --production. Typical examples of devDependencies are tools like eslint, nodemon, or testing libraries, which don’t need to be included in the final application.

This will appear in package.json as:

```json
"devDependencies": {
    "cross-env": "^10.1.0"
  }
```

# FETCH BACKEND VS FRONTEND

We can fetch data both from other sources on the client side and on the server side. Here, I’ll try to separate the two methods and explain the difference. The method for fetching data on the server and on the client can be done in the same way, but there are some essential differences and possibilities between them.

If we want to fetch data on the frontend, we can do it using fetch with either await or .then syntax — it doesn’t matter. We’ve previously worked with the Books API and its design — the fetch could look like this:

```js
fetch("https://books.com/api/books")
  .then((response) => response.json())
  .then((result) => console.log(result));
```

When we work with fetch in the frontend, we are subject to the rules imposed by the browser—for example, CORS restrictions. One disadvantage of fetching on the frontend is that we might expose our API key. If we want to use an API key without others being able to see it, we can choose to fetch the data on the server—this could look like this:

```js
const response = await fetch("https://books.com/api/books");
const result = await response.json();
console.log(result);
```

The possibilities on the server are a bit different because we can store and use secrets, we don’t have CORS restrictions, and we can process and manipulate our data more complexly before sending it to the frontend. If we just want to display data immediately, we do it on the client; if we want to fetch data and model it in large processes, or need to keep API keys secure, we do it on the server and then send it to the frontend.

# SEMANTIC HTML

Semantic HTML is about being intentional with the HTML tags you use — so they are optimized for accessibility, SEO, and readability for search engines. Normally, you might just use `<div>` for everything because it’s easy to style and use — but that’s not very smart when it comes to HTML semantics.

What we definitely want to do is use `<nav>` for our navigation bar, `<main>` for our main content, and `<footer>` for our closing element that sits at the bottom of a webpage. You also need to be mindful of `<h1>`, `<h2>`, `<h3>` because search engines use them to determine the importance of information — whether it’s a heading or a subheading, etc. For example, it makes sense to have only one `<h1>` tag per page, while you can have multiple `<p>` tags or `<h2>`, `<h3>` tags.

# CLIENT FILES VS SERVER FILES

Our files are divided into frontend/backend or client/server files, but they can easily coexist in the same project. The main difference is that client files are visible to everyone, while server files are only seen by those writing the code (I guess :D). You could also say that client files are what users interact with to make the visuals work smoothly, whereas server files are the invisible layer that manages the data, security, and database access. It’s also typical that client files are publicly accessible, while server files are not. In this project, the client files are:

```bash
404.html
index.html
index.js
styles.js
images
```
serverfilerne er:

```bash
vercel.json
package.json
package-lock.json
app.js
markdown-files
```


# HOW TO STYLE A FOOTER SO IT STAYS AT THE BOTTOM

Maybe it’s something everyone struggles with at some point? One solution could be to use Flexbox with min-height and flex: 1 on the main tag. This would ensure that the footer element is pushed down to the bottom, no matter how much space the main element takes. It would be dynamic all the way. It could look like this:

```html
<body>
  <header>Header</header>
  <main>Main content</main>
  <footer>Footer</footer>
</body>
```

With the css:

```css
body {
  height: 100%;
  margin: 0;
  display: flex;
  flex-direction: column;
}

main {
  flex: 1;
}

footer {
  background: #333;
}
```
flex: 1 means that the main container will take up all the available space in the flex container. By doing this, it automatically pushes the footer down to the bottom of the body, regardless of how much content is inside main. Essentially, main grows to fill any leftover space, keeping the layout dynamic and the footer anchored at the bottom.

# FRONTEND STRUCTURE

There isn’t a very strict convention for how to structure your frontend — in many server-side languages or frameworks, there are tighter structures for how to set up your project, but not here. That doesn’t mean we should turn a blind eye to it and not handle it. We want to create a structure that’s optimized and works to our advantage.

At its core, it’s about creating a structure that’s easy and quick to understand, so that as a project grows, it remains easy to maintain.

For a long time, I’ve worked with a structure divided into folders that contain the HTML, CSS, and JavaScript — each file is named the same, so it’s easy to see which files belong together based on their names. That structure makes sense to me mainly because it’s what I’ve worked with the most — I’ll admit that’s not the strongest argument.

I also think a good structure could be organizing by pages, where each page has its own folder containing the related scripts and styles. That makes it quick and easy to find the folder you want to look in.

# shortcircuit syntaks

- Det her eller det her. google hvad det betyder

# proxying

A proxy is a kind of intermediary that receives a request and forwards it, then receives a response back and sends it on. It is closely related to the backend fetch we talked about earlier. In the example below, our frontend calls the endpoint we have called /proxy, which then performs a fetch to google.com and sends the response back to our frontend. It looks like this:

```js
app.get("/proxy", (req, res) => {
  fetch("https://www.google.com/")
    .then((response) => response.text())
    .then((body) => {
      res.send(body);
    });
});
```
Why do it then? We’ve already touched on keeping API keys on the server, CORS policies, and the ability to manipulate the data before sending it back to the client. 
