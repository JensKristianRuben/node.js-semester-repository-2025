# First server

## Scoping

- `const` → default choice. We only use `let` when reassignment is required.

- Absolutely no `var`.  
  One reason is that you can redeclare the same variable within the same scope, for example:

```js
function reDeclareOfSameVariable() {
  var a = 70;
  if (true) {
    var a = 90;
  }
  console.log("The value of a is:", a);
}
reDeclareOfSameVariable(); // The value of a is: 90
```

It creates confusion when reading the code. Another issue is that we can access the variable before it has been assigned a value — which results in it printing undefined. If we had done the same with let, we would have received a ReferenceError. That is easy to debug — undefined is not.

```js
var anyRandomNumber; // variable declaration
console.log(anyRandomNumber); // result: undefined
anyRandomNumber = 76;
console.log(anyRandomNumber); // result: 76V
```

## Avancerede funktioner

**Higher-order functions**

  - Functions that take other functions as arguments or return them. Examples could be: `map()`, `filter()`, `reduce()`.

  Example could be:

  ```js
  const numbers = [1, 4, 23, 10, 12, 42, 101, 82];

  const filteredNumbers = numbers.filter(isOlderThan10); // [ 23, 12, 42, 101, 82 ]

  function isOlderThan10(value) {
    return value > 10;
  }
  ```

- We see that the function `filter()` takes the function `isOlderThan10` as a parameter. That makes it a higher-order function.

- Then we will call the function `isOlderThan10` a callback function. An important note is that we do not call it with parentheses, because it is a function reference, not a function invocation.

- **Closures**

  - Funktioner husker deres scope selv udenfor den oprindelige kontekst
  - Bruges til private variabler og funktion factories

**Callback functions with different syntax**

  - There are different ways to write a callback function. I’ve chosen four ways to do it — and I wouldn’t be surprised if there are even more.

You can do it in the following ways:

```js
const numbers = [1, 4, 23, 10, 12, 42, 101, 82];

const filteredNumbers = numbers.filter(isOlderThan10);

function isOlderThan10(value) {
  return value > 10;
}

// This one is called a normal callback function.
// We separate the higher-order function and the helper function.

const moreFilteredNumbers = numbers.filter(function (value) {
  return value > 10;
});

// This one is called an anonymous function.
// It has the helper function defined inline.
// The callback function cannot be reused elsewhere.

const evenMoreFilterdNumbers = numbers.filter((value) => value > 10);

// This one is called an arrow function and does the same as the one above,
// but the syntax is more modern and shorter.
const superEvenMoreFilteredNumbers = numbers.filter((value) => {
  console.log("Checking.. Checking.. number: ", value);
  return value > 10;
});

// This one is also called an arrow function but has a block scope,
// which means you can write multiple lines of code inside.
```

## NPM

- Node Package Manager (npm) is used to manage the libraries we want to use in a Node.js application. With npm, you can install packages globally (available everywhere) or locally (available only in the current project).
- There are many different kinds of package managers — for example, we know Maven and Gradle from Java and pip from Python.

If you want to install a dependency with npm, you can use the command `npm install express` or `npm i express`. First, you need to make sure to create a file called `package.json`, which is where your dependencies are listed. Read more below.

You can also initialize a Node project with `npm init`. This will prompt you for various details in the terminal.

## package.json

- `package.json` is the manifest file for a Node project. It defines versions, dependencies, and metadata such as name, description, and license.

the format looks something like this - our school project 'tinder for indian dogs - doginder':

```json
{
  "type": "module",
  "name": "doginder",
  "version": "0.0.1",
  "description": "A tinder for Indian Dogs",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["Tinder", "Dogs", "Indian", "Love", "Romance"],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "express": "^5.1.0"
  }
}
```

- `package-lock.json` is an automatically generated file that locks the exact versions of all installed packages and their dependencies. It ensures that everyone working on the project gets exactly the same versions of the packages, creating consistency and preventing unexpected issues during installation.

## Express server

- When setting up an Express server, the first thing you do is make sure to add Express to your `package.json`.  
  This means that inside your project — typically in a file called `app.js` — you can import the Express library.  
  After importing Express, you can initialize it by calling `express()` and assigning it to a variable, usually named `app`.  
  Now we have our server ready, but we still need to tell it which port to run on. This can be done using the `listen()` method, which is a function that can take two arguments — the port to listen on and a callback function.

It looks like this:

```js
const express = require("express"); // import - old way - should use the ECMAScript way

const app = express(); // initializing the server.

const PORT = 8080;
app.listen(PORT, () => {
  // which port to listen to
  console.log("The server is running on port:", PORT);
});
```

## GET requests

-When creating an endpoint on an Express server, we use `app` and specify which HTTP method it should use. In this case, it will be `app.get()` because we want to retrieve data.  
The method takes two arguments: the URL that the endpoint should be mapped to (in this case, the root `/`) and a callback function with the parameters `(req, res)`. I like this way of writing it because it clearly illustrates the client-server model with a request and a response. We receive some input and need to send something back — in the meantime, we might even save the world.

When sending a response back, we make sure to send it in JSON format. If we want to be extra thorough, we can wrap our payload inside a `data` object.

A full endpoint could look something like this:

```js
app.get("/", (req, res) => {
  res.send({ data: `message: Hello from express!` });
});
```

## node_modules

- Contains all the packages that are installed via npm in the project.
- The folder is generated automatically when running `npm install` and includes both the direct dependencies you have installed and all of their dependencies.
- It should not be versioned in Git, because it can become very large, and all dependencies can be recreated from `package.json` and `package-lock.json`.
- If sharing the project with others, they just need to run `npm install` to get all the necessary packages installed locally.
