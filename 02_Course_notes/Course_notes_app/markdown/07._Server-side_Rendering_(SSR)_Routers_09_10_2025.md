## Kan bruge disse til at rendere på serveren
```js
const frontpagePage = fs
  .readFileSync("./public/pages/frontend/index.html")
  .toString();
const matchesPage = fs
  .readFileSync("./public/pages/matches/matches.html")
  .toString();
```
## Nodemon - man kan lave en nodemon.js fil i roden som man kan definere forskellige regler for hvordan nodemon skal køre


# SSR VS. CSR

I would like to dive into this based on the following points: load time, resources spent (duration, when and where), SEO, and dealing with CORS (SSR has no CORS issues).

Regarding load time, we can look at it like this:

With server-side rendering, the server sends fully rendered HTML to the browser. This means the user sees the content almost immediately, which is especially helpful for the first page load. It’s perfect for pages where the first impression is important, such as blogs, marketing sites, or e-commerce.

When rendering on the client, the browser typically receives an empty HTML page and runs JavaScript to build the DOM and display the content. This can make the first load slower because the browser has to fetch scripts and data first. However, subsequent navigation (e.g., clicking between pages in a single-page app) can be much faster, since the content is already in the browser’s memory.

An example of SSR could be, like in this project, that you read an HTML file from the project’s files and then send it to the client. In this snippet, I also fetch some data from markdown files and convert it to HTML using the library marked, which magically takes care of it. I then send the HTML as a string to the client — which itself figures out how to render it as HTML.

```js
const indexPagePath = path.join(__dirname, "public", "index.html");
let indexPage = fs.readFileSync(indexPagePath).toString();

const fourZeroFourPagePath = path.join(__dirname, `public`, "404.html");
const fourZeroFourPage = fs.readFileSync(fourZeroFourPagePath).toString();

app.get("/markdown/:file", (req, res) => {
  const fileName = req.params.file;
  const markdownFilePath = path.join(__dirname, "markdown", `${fileName}.md`);

  if (!fs.existsSync(markdownFilePath)) {
    res.status(404).send(fourZeroFourPage)
  }

  const markdownContent = fs.readFileSync(markdownFilePath).toString(); // læser og laver det til en string
  const parsedMarkdownContent = marked.parse(markdownContent); // konvertere det til html

  const indexPageToSend = indexPage
    .replace("$$MARKDOWNCONTENT$$", parsedMarkdownContent)
    .replace("$$TITLE$$", `Fullstack node.js notes - ${fileName}`);

  res.send(indexPageToSend);
});
```
The example above is not optimized and reflects how the code is written now — it’s not ideal that it has to read the markdown content every time the endpoint runs, for example.

An example of a client-rendered page could be a clock game I made — the client reads an HTML file and fills in some of the elements itself based on the JavaScript that has been written.

Regarding resources, we can look at it like this:

Server-Side Rendering: The server does most of the work generating the HTML. Each request requires server computing, which can put a load on the CPU, especially with many concurrent users. The advantage is that the client doesn’t need to use as many resources, meaning even older or slower devices can display the page quickly.

Client-Side Rendering: The browser handles both rendering and data fetching, which reduces server load. On the other hand, the client device uses more CPU and memory, especially if the page is heavy or complex. Rendering happens in the browser first, so the user has to wait for scripts and data before the content is displayed.

Regarding SEO:

Server-Side Rendering: Search engines see the fully rendered HTML directly, which improves indexing. This makes SSR particularly well-suited for pages where SEO is important.

Client-Side Rendering (CSR): Search engines can have difficulty indexing content that is generated via JavaScript.

Regarding CORS:

Server-Side Rendering: The server can contact other APIs directly without running into CORS restrictions, because CORS only applies to the browser. This provides flexibility, especially when fetching data from third-party APIs.

Client-Side Rendering: The browser is subject to CORS rules, so if you try to fetch data from a domain that does not allow your origin, the request will be blocked.


# MEMORY & EFFICIENCY

The way we structure our code determines how we use the computer’s resources—there are many factors to consider. A classic example is where we place variable declarations—are they global or local, and are they called once or multiple times? If this happens inside an endpoint or a method, is it appropriate or not? For instance, large arrays or objects in the global scope occupy memory for the entire lifetime of the application. This also means that temporary data should preferably be limited to the function’s scope so that garbage collection can free up memory. We can also consider that inefficient loops or repeated calculations can strain the CPU. This is not something we have covered extensively in class, but caching or memoization can be used where it makes sense to avoid unnecessarily running processes again.

# CODE STRUCTURE