# INTRODUCTION

## GIT

Git is a version control tool. When you create a project, you can initialize it as a local Git repository, which means it starts saving the `commits` you make. The word itself gives a hint — when you have a portion of code you want to save, you `commit` it. This means a `snapshot` of the code is taken — the smart thing about this is that you can return to an earlier `commit` if you encounter bugs or issues with your code.

If you want to start your project as a Git project, you can use the command:

```bash
git init

```

 This initializes a history, which means that from then on you can use Git commands to manage the version of your code. It’s important to note that Git can be used to version control anything — not just code.

There are many things to understand about Git, and when you first start working with Git in the console, it can feel overwhelming and confusing. You can use the following command to get an overview:

 ```bash
git status
 ```
It will tell you which branch you are working on and which files have been changed and can be committed. If you want to save some new code, you first need to stage your code — that basically means putting it “in line” to be committed. You can do this with one of the following commands:


 ```bash
git add .
git add -A
 ```

`git add .` adds all the changes that have occurred recursively from the path you are currently in.
`git add -A` includes everything in the project — even changes that have occurred at a higher file level. 

This means that the code is now staged — you would also be able to see this in your git status. We can now commit the code. When you make a commit, you also include a commit message that describes what has been changed. You should aim to write clear and descriptive commit messages — this helps others understand a change without having to read the code. The command looks like this:

```bash
git commit -m "commit message: added a index.html file - added title and header"

```

Now comes the tricky part — up until now, we have only been working by ourselves and locally on our PC. But another great thing about Git is that it makes it easy to collaborate with others on the same project. One aspect is version control — we can easily roll something back if someone has made a mistake. But you can also create what is called a branch, which is a copy of the code as it currently is, where you can continue working. Once you have added the desired changes, you can merge your branch back into the main project, also called `main`. This is useful because we want to maintain a clean and working version of our project without errors or bugs — that is our `main`. When we want to branch out from the project, we can do so with:


```bash
git checkout -b "feature-branch"

```

Now we are working on the branch `feature-branch` and adding things. The changes are ready to be added back to the main project `main`. This is done with the command:


```bash
git merge main 

```

We want to make sure we have the latest changes that have been made in the `main` branch, so we merge the main project into our branch. This means that our branch now, in principle, contains the content of the `main` branch plus the changes we have made. We can now push our branch to a remote repository. Some companies provide Git in the cloud, making it possible to collaborate and store projects. Examples include GitLab or GitHub. Now we want to push our branch to our shared repository so it can be merged into the `main` branch. We do this with:

```bash
git push -u origin "feature-branch"
git push

```

If it’s the first time, we need to specify the name of the remote branch — it doesn’t exist yet. After that, we can simply use `git push`.

On GitHub, you create what is called a pull request, which is a request to the others in the project asking to pull your changes into the main branch — in principle, it is a `git` merge that happens underneath.

afslutningvis vil vi gerne trække ændringerne i `main` ned lokalt igen. Det kan man gøre med: 


```bash
git pull

```

If there are changes to be found, you can see them in the terminal; if not, you will be informed that your project is up to date. Before branching out from main, it’s a good idea to run git pull.



## DATA TYPES

I javascript findes der otte forskellige datatyper

`String` – A sequence of text characters wrapped in quotes, e.g. "Hello".

`Boolean` – A logical value, either true or false.

`Number` – Numeric values (integers or decimals), e.g. 42 or 3.14.

`BigInt` – Very large integers beyond the safe range of Number, e.g. 123n.

`Object` – A collection of key–value pairs, e.g. {name: "Anna", age: 25}.

`Symbol` – A unique and immutable identifier, often used as an object key.

`undefined` – A variable that has been declared but not assigned a value.

`null` – An intentional empty value representing "no value".


## WHAT IS NODE.JS

Normally, we know JavaScript from use in browser scripts, DOM manipulation, or client-side rendering of data. But Node.js takes JavaScript out of the browser and makes it possible to run in a runtime environment. It is built on Chrome’s V8 engine and is often used to create servers, APIs, or other types of backend applications. If you want to run a Node.js application, you need to find the path where the file is located an and type:

```js

node app.js

```

##  TYPE COERCION

Type coercion is when JavaScript automatically converts a value from one data type to another. For example, if you compare the string "false" with the boolean value false, JavaScript may try to convert the types to make the comparison work, which often leads to unexpected results. Another example is adding the string "5" to the number 10; the result becomes "510" because the number is automatically converted to a string. To avoid type coercion, you can use strict equality === instead of ==, since === checks both the value and the type, resulting in more predictable code. If we want to add a number to a string, we can use the Number() or parseFloat() methods to convert (cast) the string into a number first.

```js

let strNum = "10";
let num = 5;

let result = Number(strNum) + num; // 15
```

## REST API

We work with five different HTTP verbs: GET, POST, PUT, PATCH, and DELETE.

GET: used to retrieve one or more records.
POST: used to create a new record.
PUT: used to update an entire record.
PATCH: used to update part of a record..
DELETE: used to remove a record.

Endpoints should be named using nouns in plural form, and the name should match the name used for the records in your database. For example, if your endpoint is /books, the collection in your database should also be called books. It is considered bad practice to name an endpoint something like /getBooks.


## REST API DESIGN

The following should demonstrate how you can design your API based on REST conventions. Notice that GET appears twice, and that PUT and PATCH do the same thing, but not exactly in the same way.

GET /books – Retrieves a list of all books in the collection.

GET /books/{id} – Retrieves a single book by its ID.

POST /books – Creates a new book.

PUT /books/{id} – Updates an entire book, replacing all its data.

PATCH /books/{id} – Updates part of a book, e.g., only the title or author.

DELETE /books/{id} – Removes a book from the collection.