# HTML / TIME

## CRUDable REST API

Alright. A fully CRUDable API following the REST convention. In the introduction, we already touched on how to design a REST API. We used books as an example — it looked like this:


- GET api/books – Retrieves a list of all books in the collection.

- GET api/books/{id} – Retrieves a single book by its ID.

- POST api/books – Creates a new book.

- PUT api/books/{id} – Updates an entire book, replacing all its data.

- PATCH api/books/{id} – Updates part of a book, e.g., only the title or author.

- DELETE api/books/{id} – Removes a book from the collection.

**GET**

I think I’ll create all the endpoints and comment on them along the way. The starting point will be a list of book objects stored in memory in the code — we’re not at the stage where we connect a real database yet, although many of the same ideas apply whether it’s in memory or a real database server being communicated with.

```js
const books = [
  { id: 1, title: "The Hobbit", author: "J.R.R. Tolkien" },
  { id: 2, title: "1984", author: "George Orwell" },
  { id: 3, title: "To Kill a Mockingbird", author: "Harper Lee" },
];
```

Let’s start by looking at how we could create a GET endpoint for all books. We know the endpoint should end with /books if we follow our design above. I’ve also chosen to add /api before it, to separate the endpoints that serve HTML pages from those that serve data. This means we could, for example, have an endpoint called /books that serves a books.html page.

```js
app.get("/api/books", (req, res) => {
  res.send({data: books});
});
```
It’s very simple. When /api/books is accessed, we use the response object (res) to send data back to where the request came from (req). It’s important to note that we wrap our JavaScript object in a JSON object and send it back to the requester. This means they receive it as a JSON object and can process it accordingly.

**GET**

Now we come to the next endpoint — it’s for fetching a specific book. It’s important to understand the difference: /api/books retrieves all books, but now we want to fetch a single book — based on its ID. If you look at our books list above, each entry has an ID — 1, 2, and 3, respectively. Let’s say we want to fetch the book with id = 1.

```js
app.get("/api/books/:id", (req, res) => {
    const id = req.params.id;
    const book = books.find(book => book.id == id);

    if (!book){
       return res.status(404).send({data: `not found book with id: ${id}`});
    }

    res.send({data: book});
});
```
This means that in the browser we can type /api/books/1, which will return:

```json
{
  "data": {
    "id": 1,
    "title": "The Hobbit",
    "author": "J.R.R. Tolkien"
  }
}
```

We can use the syntax /:id, which maps what is written in the URL to the ID. This means we can use the request object, which contains values from the request itself, like:
 ```js
 const id = req.params.id;
 ```
 to extract the ID so we can use it in the code. Afterwards, we check whether the ID exists in our list of books. I also introduce an error check — what is called an early return — which ensures that if the ID does not exist, a 404 status code and a message indicating that the ID was not found will be sent. Finally, we use the response object to send the data back to where the request came from.

 **POST**

We have now reached the endpoint that handles creating a book — that is, when you want to add a new book to the database. This is called a POST request.
In terms of design, this endpoint looks almost exactly like our first GET endpoint; the main difference is the HTTP verb, which in this case is POST.

With a POST request, some data is typically included in the request body, which we want to capture and add to our list of books. Finally, we send a response back to confirm that the data has been successfully created.
It could look like this:

```js
app.post("/api/books", (req, res) =>{

     if (!req.body) {
        return res.status(400).send({ errorMessage: "Requires a JSON body" })
    }

    let newBook = req.body;
    newBook.id = nextId++
    books.push(newBook);

    res.status(201).send({data: newBook})
});
```

We check whether there is a body in the request — and if there isn’t, we make sure to send back data indicating that a body is required to create new data. We create a variable and set it to the request’s body. We then add an ID to the new book, using nextId, which is a new variable we’ve added to keep track of the different IDs. Next, we use push() to add the new book to the list of books. Finally, we send a 201 status code, which means “Created,” along with the data that has been created.

Right now, there are plenty of issues with the code above — for example, you can create some strange books because there are no rules for which fields are required. But we’re trying to keep it simple and conceptual.


**PUT**

Finally, I would also like to point out that in order to parse JSON data, you need to add the following line:
```js
app.use(express.json());
```

Next, we will move on to our two verbs that update a record: PUT and PATCH, in that exact order. Let’s start with PUT.

ChatGPT sagde:

The idea with PUT is to fully update the record with what we send in the body — so our entire book is actually overwritten with everything sent in the body. We get the ID from the URL, find the index of the book that matches the ID. findIndex() returns -1 if it doesn’t exist — that’s why we can check it and return a 404 if it’s not found.

We extract title and author using object destructuring (you can teach an old dog new tricks, or whatever they say). The alternative would be to get them one by one. Then we can check if title and author exist — if they don’t, it means they weren’t sent in the body. Finally, we overwrite our object in the list of books and send a response back. the endpoint look like this:  


```js
app.put("/api/books/:id", (req, res) => {
    const bookId = parseInt(req.params.id);

    const bookIndex = books.findIndex(book => book.id === bookId)
    
    if (bookIndex === -1) {
        return res.status(404).send({errormessage: `Book not found with id ${bookId}` })
    }

      const { title, author } = req.body;
    if (!title || !author) {
        return res.status(400).send({ errorMessage: "All feilds are required to update book" });
    }

    books[bookIndex] = { id: bookId, title, author };

    res.send({data: books[bookIndex]})
});
```

**PATCH**

So we’re actually almost done with the API — we’ve now reached PATCH. As I’ve already mentioned, PATCH is also a way to update data, but with PATCH you can update by sending just a single field in the body — you don’t need to send the entire object. That’s why PUT and PATCH can look very similar, but the difference is that we don’t perform the same field checks as we do in PUT; it should be possible to send a body with only one field.

We also use the spread syntax, which merges a copy of the book in the list with the request body. You can think of it a bit like a main branch and a feature branch being merged. If there’s an update, it gets merged on top of the existing data. It’s important that we also include the ID so the IDs don’t get messed up — it looks like this:

```js
app.patch("/api/books/:id", (req, res) => {
  const bookId = parseInt(req.params.id);

  const bookIndex = books.findIndex((book) => book.id === bookId);

  if (bookIndex === -1) {
    return res.status(404).send({ errormessage: `Book not found with id ${bookId}` });
  }

  books[bookIndex] = {
    ...books[bookIndex],
    ...req.body,
    id: bookId,
  };

  res.send({ data: books[bookIndex] });
});
```

**DELETE**
The cherry on top is DELETE. As you might guess from the verb, it’s about removing data. DELETE is actually quite simple. It involves finding the object we want to delete in the list based on its ID, performing some checks in case non-existent data was sent, and then removing the data using the splice() method.

splice() takes two parameters — the first tells it which index to start at, and the second specifies how many elements to remove from that point.

```js
app.delete("/api/books/:id", (req, res) => {
    const bookId = Number(req.params.id);
    const bookIndex = books.findIndex(book => book.id === bookId);

    if (bookIndex === -1) {
        return res.status(404).send({ errormessage: `Book not found with id ${bookId}` })
    }

    const removedBook = books.splice(bookIndex, 1);

    res.status(200).send({data: removedBook})
});
```
So we’re done with the CRUDable REST API — that probably took 5 hours, jeez.

## DATE OBJECT

So, Dates in JavaScript. You always know you’re in for a treat when you have to deal with date formatting – it’s just so much fun. Anyway, like many other programming languages, JavaScript has a Date object that comes with a whole toolbox of methods. I’ll go through a few of them here:

If you want to get the current year / date / time, you can use the following syntax – it’s important to point out that you can format it in many different ways – by default, it matches your computer’s timezone:

```js
const rightNow = new Date()
console.log("right now: ", rightNow); // right now:  2025-10-12T15:50:10.334Z
```
If we want to, we can extract it in more specific ways — like by year, day, and so on:

```js
console.log("This year: ", rightNow.getFullYear());  //This year:  2025
console.log("This month", rightNow.getMonth());        //This month 9
console.log("This day of the month", rightNow.getDate());    //  This day of the month 12
console.log("This hour", rightNow.getHours());   //This hour 17
console.log("This minute", rightNow.getMinutes());    //This minute 54
console.log("This second", rightNow.getSeconds());    //This second 41
```

If we want it in different country formats, we can do the following:

```js
console.log("Danish:", rightNow.toLocaleDateString("da-DK")); //Danish: 12.10.2025
console.log("USA:", rightNow.toLocaleDateString("en-US")); // USA: 10/12/2025
```

## REVOLVER FETCH

So, our instructor thinks that writing a fetch should feel completely natural and lightning-fast — almost like drawing a revolver.
But first of all, what is a fetch?

It’s a built-in method in JavaScript that sends a request to, for example, an API and receives a response.
That response is actually what’s called a Promise — in a way, it’s a promise that some data will arrive at some point.
If you print out a Promise object, it typically looks something like this:

```js
const response = fetch("https://books.com/api/books");
console.log(response); // Promise { <pending> }
```

You could say it means, "I'm working on it — check back later."

If we add an await to the fetch, which tells it to wait until the promise is resolved, then we could instead print out the response object.

We’ve been working with the syntax called the .then() syntax. It’s the one you should be able to use instantly and without hesitation:

```js
fetch("https://books.com/api/books")
.then(response => response.json())
.then(result => console.log(result));
```

